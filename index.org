#+title: Diane (UNDER CONSTRUCTION)
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="indexStyle.css" />
#+HTML_HEAD: <script src="diane.js"></script>
#+OPTIONS: html-style:nil H:2 num:nil

Diane is a *toy stack-oriented language with dynamic scoping*.  It's
not pretty or all that interesting, but it's simple enough to present
the syntax and semantics in a straightforward way (and to build a
reasonable playground for it).

Diane was born out of a need to visualize evaluation.  During the 2024
spring semester at Boston University, I co-taught a course on
programming languages in which we used stack-oriented languages as a
basis for studying operational semantics.  I worked through
evaulations step-by-step on the board often enough for me to want a
tool to make the process /automatic/ and /interactive/, along the same
lines as the [[https://pythontutor.com/cp/composingprograms.html#mode=edit][Python Tutor]] for [[https://www.composingprograms.com][Composing Programs]].

*Disclaimer.* This page is not a tutorial, just a description of
the language and playground.

* The Playground
The primary goal of this project was to build a [[file:playground.html][playground]] for toying
with Diane programs using [[https://elm-lang.org][Elm]].  The playground consists of an editor
window for writing programs, a visualization window for seeing how the
stack and environment change over the course of evaluation, and a
console window for seeing intermediate print statements and error
messages.

The playground can also be embedded:
#+BEGIN_EXPORT html
  <div id="embed-example"></div>
  <script>
  var app = Elm.Main.init({
  node: document.getElementById('embed-example'),
  flags: {
  hasTrace: true,
  adjustable: false,
  program: `def SUMSQUARES {
   dup * swap dup * +
  }
  2 3 #SUMSQUARES @X
  X print

  !SUMSQUARES !X`
  }});
  </script>
#+END_EXPORT
We take advantage of this below to highlight features of the
semantics.

Partly out of laziness, partly out of a general bent towards minimal
interfaces, there are no instructions for using the playground within
the playground itself, so I've included them here.
** Instructions
+ The *step* button consumes a single command of the program in the
  editor window and updates the stack and environment accordingly.
+ The *run* button consumes as much of the program as possible until
  + the entire program is consumed
  + there is an error
  + the evaluation times out.
+ The *undo* button reverses a step taken by pressing either the
  *step* button or the *run*.
+ The *reset* button resets the program state to its initial state,
  clearing the undo history.
+ The *save* button sets the program in the editor window to be the
  program of the initial state. This also clears the undo
  history.[fn:: Note that this only saves the program, not the whole
  program state.  When reseting, the stack and environment will be
  empty, but the inital program will be the most recently saved
  program.]
+ The *clear* button in the console window clears the messages printed
  there.[fn:: This cannot be undone.]

** Keyboard Shortcuts
It's possible to step through a program while writing it using the
following keyboard shortcuts.  In most cases you can also hold down
the key to rapidly step through a program, providing a make-shift
animation mechanism.

  | key | button |
  |-----+--------|
  | \   | step   |
  |-----+--------|
  | alt | run    |
  |-----+--------|
  | `   | undo   |
  |-----+--------|

* Syntax
The following is a simple [[https://en.wikipedia.org/wiki/Extended_Backusâ€“Naur_form][EBNF Grammar]] describing a Diane program.  In
short, a program is a sequence of commands.

-----

#+begin_src
  <program>  ::= { <command> }
  <body>     ::= '{' <program> '}'
  <command>  ::= <int> | 'drop' | 'swap' | 'dup' | 'rot'
               | '+' | '-' | '*' | '/' | '%' | '=' | '<'
               | '?' <body> 'else' <body> | 'while' <body> 'do' <body>
               | 'def' <ident> <body> | '#' <ident>
               | '@' <ident> | '!' <ident>
  <int>      ::= â„¤
  <ident>    ::= ALLCAPS
#+end_src

-----

* Semantics
We take a *value* to be a integer (â„¤) or a program (â„™) representing a
subroutine.[fn:: In other word, the set of values is â„¤ âˆª â„™.] A
*configuration*, written ( S, E, P ), is made up of a stack of
integers (S), an environment consisting of identifier-value bindings (E), and a
program as given by the above grammar (P).  The [[https://en.wikipedia.org/wiki/Operational_semantics#Structural_operational_semantics][small-step/structural
operational semantics]] of Diane are given by the reduction rules
below.

*Notation.* We write E[X â†¦ A] to mean the environment E but with X
bound to the value A. We write X âˆˆ E to mean X is bound in E.  We
write E[X] for the value to which X is bound in E.  We write E/X for E
but with any binding of X removed.

** Stack Manipulation
Several commands are dedicated to manipulating the stack. We can
+ *push* an integer onto the stack
+ *drop* the top element off the stack
+ *swap* the top two elements on the stack
+ *dup*-licate the top element on the stack
+ *rot*-ate the top three elements on the stack
In the case that there aren't enough integers on the stack to perform
a given operation, a stack underflow error message is printed to the
console.

There is also an unofficial command for *print*-ing the top element of
the stack and removing it.  See the example below.[fn:: It's
unofficial because the printed values are not a part of the
configuration.  Semantically, *print* is identical to *drop*.]

#+begin_src

                 ğ‘˜ âˆˆ â„¤
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ( push )
  ( S, E, k P ) âŸ¶ ( ğ‘˜ :: S, E, P )


  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ( drop )
  ( ğ‘› :: S, E, drop P ) âŸ¶ ( S, E, P )


  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ( dropErr )
  ( âŠ¥, E, drop P ) âŸ¶ StackUnderflow


  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ( swap )
  ( ğ‘š :: ğ‘› :: S, E, swap P) âŸ¶ ( ğ‘› :: ğ‘š :: S, E, P )


  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ( swapErrâ‚ )
  ( ğ‘› :: âŠ¥, E, swap P ) âŸ¶ StackUnderflow


  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ( swapErrâ‚€ )
  ( âŠ¥, E, swap P ) âŸ¶ StackUnderflow


  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ( dup )
  ( ğ‘› :: S, E, dup P ) âŸ¶ ( ğ‘› :: ğ‘› :: S, E, P )


  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ( dupErrâ‚€ )
  ( âŠ¥, E, dup P ) âŸ¶ StackUnderflow


  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ( rot )
  ( ğ‘™ :: ğ‘š :: ğ‘› :: S, E, rot P ) âŸ¶ ( ğ‘š :: ğ‘› :: ğ‘™ :: S, E, P )


  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ( rotErrâ‚‚ )
  ( ğ‘š :: ğ‘› :: S, E, rot P ) âŸ¶ StackUnderflow


  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ( rotErrâ‚ )
  ( ğ‘› :: âŠ¥, E, rot P ) âŸ¶ StackUnderflow


  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ( rotErrâ‚€ )
  ( âŠ¥, E, rot P ) âŸ¶ StackUnderflow

#+end_src

This is a small example program using these commands.  Press the
*step* button to see how the stack changes as each command is consumed
and evaluated.  Note that the last command cannot be consumed because
there are no integers on the stack to print.  Attempting to consume it
results in a stack underflow error message.

#+BEGIN_EXPORT html
  <div id="push-example"></div>
  <script>
  var app = Elm.Main.init({
  node: document.getElementById('push-example'),
  flags: {
  hasTrace: true,
  adjustable: false,
  program: `1 2 3
  drop swap dup
  rot rot rot
  print print print print`
  }});
  </script>
#+END_EXPORT

** Arithmetic and Comparisons
The next set of commands are used to operate on the integers on the
stack.  We can
+ (+) add
+ (-) subtract
+ (*) multiply
+ (/) divide
+ (%) determine the modulus
+ (=) check for equality
+ (<) check for less-than
As above, in the case that there aren't enough integers on the stack
to perform a given operation, a stack underflow error message is
printed to the console.  Errors may also occur when trying to divide by
zero.
#+begin_src

  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ( add )
  ( ğ‘š :: ğ‘› :: S, E, + P ) âŸ¶ ( ğ‘š ï¼‹ ğ‘› :: S, E, P )


  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ( addErrâ‚ )
  ( ğ‘› :: âŠ¥, E, + P ) âŸ¶ StackUnderflow


  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ( addErrâ‚€ )
  ( âŠ¥, E, - P ) âŸ¶ StackUnderflow


    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ( sub )
  ( ğ‘š :: ğ‘› :: S, E, - P ) âŸ¶ ( ğ‘š â”€ ğ‘› :: S, E, P )


  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ( subErrâ‚ )
  ( ğ‘› :: âŠ¥, E, - P ) âŸ¶ StackUnderflow


  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ( subErrâ‚€ )
  ( âŠ¥, E, - P ) âŸ¶ StackUnderflow


  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ( mul )
  ( ğ‘š :: ğ‘› :: S, E, * P ) âŸ¶ ( ğ‘š Ã— ğ‘› :: S, E, P )


  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ( mulErrâ‚ )
  ( ğ‘› :: âŠ¥, E, * P ) âŸ¶ StackUnderflow


  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ( mulErrâ‚€ )
  ( âŠ¥, E, * P ) âŸ¶ StackUnderflow


                         n â‰  0
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ( div )
  ( ğ‘š :: ğ‘› :: S, E, / P ) âŸ¶ ( ğ‘š ï¼ ğ‘› :: S, E, P )


  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ( div )
  ( ğ‘š :: 0 :: S, E, / P ) âŸ¶ DivByZero


  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ( divErrâ‚ )
  ( ğ‘› :: âŠ¥, E, / P ) âŸ¶ StackUnderflow


  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ( divErrâ‚€ )
  ( âŠ¥, E, / P ) âŸ¶ StackUnderflow


  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ( mod )
  ( ğ‘š :: ğ‘› :: S, E, % P ) âŸ¶ ( ğ‘š mod ğ‘› :: S, E, P )


  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ( div )
  ( ğ‘š :: 0 :: S, E, % P ) âŸ¶ DivByZero


  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ( modErrâ‚ )
  ( ğ‘› :: âŠ¥, E, % P ) âŸ¶ StackUnderflow


  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ( modErrâ‚€ )
  ( âŠ¥, E, % P ) âŸ¶ StackUnderflow


                     ğ‘š ï¼ ğ‘›
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ( eq )
  ( ğ‘š :: ğ‘› :: S, E, = P ) âŸ¶ ( 1 :: S, E, P )


                     ğ‘š â‰  ğ‘›
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ( neq )
  ( ğ‘š :: ğ‘› :: S, E, = P ) âŸ¶ ( 0 :: S, E, P )


  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ( eqErrâ‚ )
  ( ğ‘› :: âŠ¥, E, = P ) âŸ¶ StackUnderflow


  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ( eqErrâ‚€ )
  ( âŠ¥, E, = P ) âŸ¶ StackUnderflow

                     ğ‘š < ğ‘›
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ( le )
  ( ğ‘š :: ğ‘› :: S, E, < P ) âŸ¶ ( 1 :: S, E, P )


                     ğ‘š â‰® ğ‘›
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ( nle )
  ( ğ‘š :: ğ‘› :: S, E, = P ) âŸ¶ ( 0 :: S, E, P )


  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ( leErrâ‚ )
  ( ğ‘› :: âŠ¥, E, = P ) âŸ¶ StackUnderflow


  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ( leErrâ‚€ )
  ( âŠ¥, E, = P ) âŸ¶ StackUnderflow

#+end_src

#+BEGIN_EXPORT html
  <div id="arith-example"></div>
  <script>
  var app = Elm.Main.init({
  node: document.getElementById('arith-example'),
  flags: {
  hasTrace: true,
  adjustable: false,
  program: `3 4 5 + * 4 swap / 7 < 5 /`
  }});
  </script>
#+END_EXPORT
** Subroutines
A subroutine is just a named program.  We can /define/ subroutines and
/call/ them.  Defining a subroutine adds a binding in the environment
of its name to the program in the body of its definition. Calling a
subroutine simply prepends its body to the program being
evaluated.[fn:: Its truly amazing to me how simple this is.]
#+begin_src

  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ( def )
  ( S, E, def F { Q } P ) âŸ¶ ( S, E[F â†¦ Q], P )


    F âˆˆ E                  E[X] âˆˆ â„™
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ( call )
  ( S, E, #F P ) âŸ¶ ( S, E, E[F] P )


    F âˆˆ E             E[X] âˆ‰ â„™
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ( callErrâ‚ )
  ( S, E, #F P ) âŸ¶ InvalidCall


                  F âˆ‰ E
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ( callErrâ‚€ )
  ( S, E, #F P ) âŸ¶ UnknownVariable

#+end_src

#+BEGIN_EXPORT html
  <div id="arith-example"></div>
  <script>
  var app = Elm.Main.init({
  node: document.getElementById('arith-example'),
  flags: {
  hasTrace: true,
  adjustable: false,
  program: `def INCR {
   1 +
  }

  2 #INCR
  5 #INCR #INCR

  def DUPTWO {
   swap
   dup rot
   dup rot
   swap
  }

  #DUPTWO`
  }});
  </script>
#+END_EXPORT
** Variables
A variable is just a named integer. We can
+ /assign/ an integer to a variable, which adds a binding to the environment
+ /free/ a variable, removing its binding from the environment[fn::
  This is useful if we want to make sure it isn't accidentally
  referred to later on in the program.]
+ /lookup/ a variable binding in the environment (by just typing the variable itself)
#+begin_src

  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ( assign )
  ( ğ‘› :: S, E, @X P ) âŸ¶ ( S, E[X â†¦ ğ‘›], P )


  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ( assignErrâ‚€ )
  ( âŠ¥, E, @X P ) âŸ¶ StackUnderflow


                 X âˆˆ E
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ( call )
  ( S, E, !X P ) âŸ¶ ( S, E/X, P )


                 X âˆ‰ E
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ( call )
  ( S, E, !X P ) âŸ¶ UnknownVariable


    X âˆˆ E                    E[X] âˆˆ â„¤
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ( lookup )
  ( S, E, X P ) âŸ¶ ( E[X] :: S, E, P )


    X âˆˆ E              E[X] âˆ‰ â„¤
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ( lookupErrâ‚ )
  ( S, E, X P ) âŸ¶ InvalidLookup


                 X âˆ‰ E
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ( call )
  ( S, E, X P ) âŸ¶ UnknownVariable

#+end_src

#+BEGIN_EXPORT html
  <div id="arith-example"></div>
  <script>
  var app = Elm.Main.init({
  node: document.getElementById('arith-example'),
  flags: {
  hasTrace: true,
  adjustable: false,
  program: `1 @X
  2 @Y
  3 @X
  X Y + @Z
  !X !Y !Z`
  }});
  </script>
#+END_EXPORT
** Conditionals
Finally, there are if-statements for conditional reasoning.  We also
include while-loops with the usual semantics.
#+begin_src

                           ğ‘› â‰  0
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ( ifTrue )
  ( ğ‘› :: S, E, ? { Qâ‚ } else { Qâ‚‚ } P ) âŸ¶ ( S, E, Qâ‚‚ P )


  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ( ifFalse )
  ( 0 :: S, E, ? { Qâ‚ } else { Qâ‚‚ } P ) âŸ¶ ( S, E, Qâ‚ P )


  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ( ifErrâ‚€ )
  ( âŠ¥, E, ? { Qâ‚ } else { Qâ‚‚ } P ) âŸ¶ StackUnderflow


  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ( while )
  ( S, E, while { Qâ‚ } do { Qâ‚‚ } P ) âŸ¶
  ( S, E, Qâ‚ ? { Qâ‚‚ while { Qâ‚ } do { Qâ‚‚ } } else { } P )

#+end_src

#+BEGIN_EXPORT html
  <div id="cond-example"></div>
  <script>
  var app = Elm.Main.init({
  node: document.getElementById('cond-example'),
  flags: {
  hasTrace: true,
  adjustable: false,
  program: `0 @N

  N 5 = ? {
   24 print
  } else {
   37 print
  }

  while { 5 N < } do {
   N print
   1 N + @N
  }
  !N`
  }});
  </script>
#+END_EXPORT
